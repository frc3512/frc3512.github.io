<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="description" content="Event Framework Lab">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Event Framework Lab - FRC Team 3512</title>
  <script src="../../../toc.js">
  </script>
  <link rel="stylesheet" type="text/css" href="../../../style.css">
</head>
<body onload="tableOfContents();">
  <div class="title">
    <h1>Event Framework Lab<br>
    <small>Control Theory 1</small></h1>
  </div>
  <div id="toc"></div>
  <p>In the previous lab, we used a switch-case structure to implement a state
  machine. Hopefully, you are now able to understand and implement complex
  robot actions over time in terms of state machines. In this lab, we are going
  to learn about the event-driven paradigm and apply it to state machine
  design.</p>
  <p>The previous state machine lab used a switch-case structure to implement
  the state machine. There are more complicated ways to formulate state
  machines that provide more expressive power, such as an event-driven
  paradigm. In this paradigm, any change in external state is considered an
  event (e.g., button press/release, digital input rising edge, timer
  expiration). The current state in a state machine can choose to consume the
  event and initiate a state transition.</p>
  <h2 id="Hierarchical_State_Machines">Hierarchical State Machines</h2>
  <p>State machines can also serve as states themselves. When the parent state
  machine transitions to it, events received by the parent state machine are
  passed down to the child state machine which can consume it first and cause a
  transition. If the event isn't consumed, it is passed up the hierarchy to
  parent state machines which can choose to consume it. If none do, the event
  is discarded.</p>
  <h2 id="Understanding_the_Problem">Understanding the Problem</h2>
  <p>For this lab, you will modify your solution for the <a href=
  "../state-machine/">previous state machine lab</a> to use our event-driven
  framework instead of a switch-case structure.</p>
  <h2 id="Setup">Setup</h2>
  <p>Make another project containing the same files as your previous solution,
  then copy the following event framework files into it. A new
  <code>Main.cpp</code> is provided as a starting point.</p>
  <ul>
    <li>
      <a href="DigitalInputHandler.cpp">DigitalInputHandler.cpp</a>
    </li>
    <li>
      <a href="DigitalInputHandler.hpp">DigitalInputHandler.hpp</a>
    </li>
    <li>
      <a href="Main.cpp">Main.cpp</a>
    </li>
    <li>
      <a href=
      "Events/DigitalInputEventGenerator.cpp">Events/DigitalInputEventGenerator.cpp</a>
    </li>
    <li>
      <a href=
      "Events/DigitalInputEventGenerator.hpp">Events/DigitalInputEventGenerator.hpp</a>
    </li>
    <li>
      <a href="Events/EventAcceptor.hpp">Events/EventAcceptor.hpp</a>
    </li>
    <li>
      <a href="Events/EventGenerator.hpp">Events/EventGenerator.hpp</a>
    </li>
    <li>
      <a href=
      "Events/JoystickEventGenerator.cpp">Events/JoystickEventGenerator.cpp</a>
    </li>
    <li>
      <a href=
      "Events/JoystickEventGenerator.hpp">Events/JoystickEventGenerator.hpp</a>
    </li>
    <li>
      <a href=
      "Events/TimerEventGenerator.hpp">Events/TimerEventGenerator.hpp</a>
    </li>
    <li>
      <a href="SM/State.cpp">SM/State.cpp</a>
    </li>
    <li>
      <a href="SM/State.hpp">SM/State.hpp</a>
    </li>
    <li>
      <a href="SM/StateMachine.cpp">SM/StateMachine.cpp</a>
    </li>
    <li>
      <a href="SM/StateMachine.hpp">SM/StateMachine.hpp</a>
    </li>
  </ul>
  <h2 id="Implementation">Implementation</h2>
  <p>Our 2016 robot used an event-driven framework for the state machines. It
  uses a State class with the following function objects which can contain
  <a href="http://en.cppreference.com/w/cpp/language/lambda">lambda
  functions</a>. See examples of lambda functions <a href=
  "http://en.cppreference.com/w/cpp/language/lambda#Example">here</a>.</p>
  <ul>
    <li>Entry (upon entering a state)</li>
    <li>CheckTransition (returns name of the next state if an event caused a
    transition)</li>
    <li>Run (while within a state)</li>
    <li>Exit (upon exiting a state)</li>
  </ul>
  <p>The StateMachine class handled calling those functions at the appropriate
  time.</p>
  <p>Here's an example state machine from our 2016 robot:</p>
  <pre>TODO: example</pre>
  <p>TODO: Documentation on example here.</p>
  <p>Once you are satisfied with your state machine diagram, translate it into
  C++ and test it. <code>Main.cpp</code> provides a template for you to do so.
  You shouldn't need to modify the RobotMock and Timer classes. We recommend
  adding print statements upon entering and exiting your states so the state
  machine's progress is externally visible.</p>
  <h2 id="Submission">Submission</h2>
  <p>Use the folder name <code>event-framework</code> for this project. Once
  you are confident your state machine works, let your instructor know and they
  will review your work.</p>
</body>
</html>
