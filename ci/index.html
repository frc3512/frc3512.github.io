<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="description" content="Curriculum and instruction">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Curriculum and instruction - FRC Team 3512</title>
  <link rel="stylesheet" type="text/css" href="../main.css">
  <link rel="shortcut icon" type="image/ico" href="../favicon.ico">
</head>
<body>
  <header id="navbar">
    <ul>
      <li>
        <a href="../">Home</a>
      </li>
      <li>
        <a href="../admin/">Admin</a>
      </li>
      <li>
        <a href="../bootstrap/">Developer Bootstrap</a>
      </li>
      <li>
        <a href="../vpn/">VPN Setup</a>
      </li>
      <li>
        <a href="./" class="active">Curriculum</a>
      </li>
      <li>
        <a href="../fll/">FLL</a>
      </li>
      <li>
        <a href="../archives/">Archives</a>
      </li>
    </ul>
  </header>
  <div class="body">
    <h1>Curriculum and instruction</h1>
    <h2 id="The_mindset_of_an_egoless_engineer">The mindset of an egoless
    engineer</h2>
    <p>The following maxim summarizes what we hope to teach students on the
    software team (with examples drawn from controls engineering).</p>
    <blockquote>
      Engineer based on requirements, not an ideology.
    </blockquote>
    <p>Engineering is filled with trade-offs. The tools should fit the job, and
    not every problem is a nail waiting to be struck by a hammer. Instead,
    assess the minimum requirements (min specs) for a solution to the task at
    hand and do only enough work to satisfy them; exceeding your specifications
    is a waste of time and money. If you require performance or maintainability
    above the min specs, your min specs were chosen incorrectly by
    definition.</p>
    <p>Controls engineering is pragmatic in a similar respect: <i>solve. the.
    problem</i>. For control of non-linear systems, <a href=
    "https://faculty.washington.edu/devasia/Inversion.html">plant inversion</a>
    is elegant on paper but doesn't work with an inaccurate model, yet using a
    theoretically incorrect solution like linear approximations of the
    non-linear system works well enough to be used industry-wide. There are
    more sophisticated controllers than PID, but we use PID anyway for its
    versatility and simplicity. Sometimes the inferior solutions are more
    effective or have a more desirable cost-benefit ratio than what the control
    system designer considers ideal or clean. Choose the tool that is most
    effective.</p>
    <p>Solutions need to be good enough, but do not need to be perfect. We want
    to avoid integrators as they introduce instability, but we use them anyway
    because they work well for meeting tracking specifications. One should not
    blindly defend a design or follow an ideology, because there is always a
    case where its antithesis is a better option. The engineer should be able
    to determine when this is the case, set aside their ego, and do what will
    meet the specifications of their client (e.g., system response
    characteristics, maintainability, usability). Preferring one solution over
    another for pragmatic or technical reasons is fine, but the engineer should
    not care on a personal level which sufficient solution is chosen.</p>
    <p>This is egoless engineering.</p>
    <h2 id="Advice_for_FRC_software_teams">Advice for FRC software teams</h2>
    <h3 id="Engineering_is_about_meeting_requirements">Engineering is about
    meeting requirements</h3>
    <p>If you can meet your requirements with a simpler, less comprehensive
    design, do it. Keep in mind that your requirements can and should include
    cleanliness, readability, and reusability.</p>
    <h3 id="Make_your_code_as_simple_as_possible">Make your code as simple as
    possible</h3>
    <p>Make your code as simple as possible while still meeting your
    functionality and cleanliness requirements. You'll thank yourself later
    when you have to debug it or reuse it.</p>
    <p>A lot can be accomplished with no feedback control and a few lines of
    WPILib. In FRC team 3512's rookie year, their 2011 robot had 100 lines of
    C++ with fully manual control except for a limit switch for automatically
    deploying the minibot. It seeded 7th out of 63 teams. Only start writing
    big, fancy abstractions when it helps attain something that couldn't be
    done easily otherwise.</p>
    <h3 id="Know_the_standard_library_and_WPILib">Know the standard library and
    WPILib</h3>
    <p>There are a lot of difficult problems in robotics and computer science,
    but most of the ones relevant to FRC were already solved by experts in
    those fields. That expertise is made available in libraries such as the
    <a href="https://en.cppreference.com/w/cpp">C++ standard library</a> and
    <a href="https://docs.wpilib.org/en/stable/">WPILib</a>. Learn their APIs
    well and use them. There's no use in reinventing the wheel (poorly).</p>
    <h3 id="Be_pragmatic_in_design_and_implementation">Be pragmatic in design
    and implementation</h3>
    <p>PID control isn't a silver bullet, and neither is computer vision. Don't
    decide to implement something just because it's cool. Implement what gives
    the highest return on investment first for robot performance. For example,
    if you want to spend a week on tuning an elevator PID controller, be
    prepared to show how that will improve the robot's scoring potential
    compared to manual control of the elevator height.</p>
    <h2 id="Minimum_laptop_specifications">Minimum laptop specifications</h2>
    <p>For FRC-specific C++ software development, we suggest the following
    minimum laptop specifications.</p>
    <ul>
      <li>Intel i3 (i5 is preferred)</li>
      <li>4GB of RAM</li>
      <li>64GB SSD (128GB if a dual boot is desired)</li>
      <li>Capable of running Linux</li>
    </ul>
    <p>SSDs are preferred because hard disk drives are slow, are typically a
    performance bottleneck, and can be damaged by drops at competition.</p>
    <p>While Linux is not required, students generally have a nicer development
    experience in Linux than in Windows. A virtual machine works for this
    purpose, but it's slower and more resource-intensive than dual-booting.
    WPILib officially supports <a href=
    "https://ubuntu.com/download">Ubuntu</a>, but a mentor uses <a href=
    "https://archlinux.org/download/">Arch</a>.</p>
    <h2 id="Curriculum">Curriculum</h2>
    <p>This page serves as a repository of knowledge for topics the software
    team has explored in the past and topics alumni are learning in college.
    Students probably won't be able to learn everything in one year, but
    students are encouraged to learn outside of build sessions to become
    effective members as soon as possible.</p>
    <p>The material here is not a complete guide. It is intended to complement
    lectures and discussion.</p>
    <p>Don't forget that the internet is a valuable resource for software
    development and engineering. This includes <a href=
    "https://www.google.com/">Google</a>, <a href=
    "https://scholar.google.com/">Google Scholar</a>, Stack Overflow, and
    Wikipedia. The latter two are most easily utilized through an indexing
    search engine like Google.</p>
    <p>See <a href="#Submission">this section</a> for assignment submission
    instructions. The available modules are listed below.</p>
    <details>
      <summary class="curriculum">
        Software engineering / robotics
      </summary>
      <h3 id="Intro_to_C.2B.2B">Intro to C++</h3><a href=
      "intro-to-cpp/">Module</a>
      <p>Introduces the fundamentals of computer programming and software
      design. Topics include variables, data types, assignment, expressions,
      basic I/O, control flow, functions and parameters, scope, and data
      structures.</p>
      <h3 id="Intro_to_Git">Intro to Git</h3><a href=
      "intro-to-git/">Module</a><br>
      Presentation: <a href="intro-to-git/lecture/">Git</a>
      <p>Introduces version control systems and their uses. This module is
      taught using Git. Installation of Git, setting up user identification for
      commits, and basic workflow are covered, with emphasis on the use of
      branches to manage work between repositories.</p>
      <h3 id="GitHub">GitHub</h3><a href="github/">Module</a><br>
      Presentation: <a href="github/lecture/">Git (advanced usage)</a>
      <p>Expands on the set of commands and techniques learned from the
      previous module with a heavy emphasis on the graph theory operations of
      Git. Topics include tags, rebasing, and managing repository history.
      These tools will be applied to working with Gerrit, a code review
      system.</p>
      <h3 id="Intro_to_real-time_software">Intro to real-time
      software</h3><a href="intro-to-real-time-software/">Module</a><br>
      Presentation: <a href="intro-to-real-time-software/lecture/">Real-time
      software</a>
      <p>Covers real-time requirements (e.g., determinism) and methods for
      meeting them.</p>
      <h3 id="State_machines">State machines</h3><a href=
      "state-machines/">Module</a> (90% complete)<br>
      Lab: <a href="state-machines/state-machine/">State machine</a><br>
      Lab: <a href="state-machines/event-framework/">Event framework</a>
      <p>State machines are presented as a simple yet effective tool for
      automating complex robot actions.</p>
      <h3 id="Control_theory">Control theory</h3><a href=
      "control-theory/">Module</a><br>
      Lab: <a href="control-theory/live-grapher/">LiveGrapher</a>
      <p>Introduces FRC students to the broader field of control theory. The
      end goal is teaching students enough such that they can make informed
      decisions regarding control system design trade-offs.</p>
      <h3 id="Robot_software">Robot software</h3><a href=
      "robot-software/">Module</a>
      <p>Applies the various skills learned in the previous modules to the
      control of electromechanical systems in FRC. Robot software design
      patterns are covered as well as features of WPILib and FRC team 3512's
      custom classes.</p>
    </details><br>
    <details>
      <summary class="curriculum">
        Miscellaneous computer science
      </summary>
      <h3 id="Advanced_C.2B.2B">Advanced C++</h3><a href=
      "advanced-cpp/">Module</a> (30% complete)<br>
      Submodule: <a href="advanced-cpp/high-performance-and-embedded/">High
      performance and embedded</a><br>
      Submodule: <a href="advanced-cpp/concurrency-and-atomics/">Concurrency
      and atomics</a><br>
      Submodule: <a href="advanced-cpp/parallelism/">Parallelism</a><br>
      Submodule: <a href="advanced-cpp/networking/">Networking</a>
      <p>Covers more advanced topics such as threading, synchronization, and
      concurrency, parallelism, asynchronous data passing (i.e. networking).
      Proper use of C++11 threads, mutexes, and atomics will be taught. SFML is
      used to instruct students in the proper use of UDP and TCP sockets, as
      well as when to use each type.</p>
      <h3 id="Intro_to_Shell_Scripting">Intro to Shell Scripting</h3><a href=
      "intro-to-shell-scripting/">Module</a> (20% complete)
      <p>Introduces writing shell scripts using Bash. Shell scripts will be
      used to automate sequences of commands to optimize parts of one's
      workflow.</p>
      <h3 id="Intro_to_Python">Intro to Python</h3><a href=
      "intro-to-python/">Module</a>
      <p>Introduces the scripting language Python. WPILib's <i>wpiformat</i>
      will be used as a motivating project.</p>
      <h3 id="Intro_to_HTML">Intro to HTML</h3><a href=
      "intro-to-html/">Module</a>
      <p>Introduces website design using HTML, CSS and Javascript. Emphasis is
      placed on writing HTML5 conformant web pages.</p>
      <h3 id="Computer_vision">Computer vision</h3><a href=
      "computer-vision/">Module</a> (0% complete)
      <p>Teaches basic image processing using the OpenCV computer vision
      library.</p>
      <h3 id="Artificial_neural_networks">Artificial neural
      networks</h3><a href="artificial-neural-networks/">Module</a> (0%
      complete)
      <p>Introduces the field of machine learning with the perceptron. A basic
      example in vision processing is presented.</p>
      <h3 id="Graphical_user_interfaces">Graphical user interfaces</h3><a href=
      "graphical-user-interfaces/">Module</a> (20% complete)
      <p>Introduces designing graphical user interfaces with the Qt graphics
      toolkit.</p>
    </details>
    <p><a href="https://missing.csail.mit.edu/">The Missing Semester of Your CS
    Education</a></p>
    <h2 id="Lesson_plan">Lesson plan</h2>
    <h3 id="Offseason">Offseason</h3>
    <ul>
      <li>Rookie training</li>
      <ul>
        <li>Teach C++ first in offseason with <a href="intro-to-cpp/">Intro to
        C++</a> module
        </li>
        <li>Start state machines and labs in November</li>
      </ul>
      <li>Veteran training</li>
      <ul>
        <li>Improvements to prev year's robot code in offseason</li>
        <li>Learn modern control theory</li>
      </ul>
    </ul>
    <h3 id="Build_season">Build season</h3>
    <p>Document what students have done at the end of each build session
    (provides external and internal documentation for hand-off and use by other
    subteams).</p>
    <p>Parentheses at end of line have date range. End of range is due date.
    Due date uses end of day. Can be M, T, W, Th, F, St, or Sn.</p>
    <h4 id="Week_1">Week 1</h4>
    <ul>
      <li>Rookie training</li>
      <ul>
        <li>Git lecture (M)</li>
        <li>As much C++ as we can (M-St)</li>
      </ul>
      <li>Veteran training</li>
      <ul>
        <li>Quick review of Git and C++ fundamentals (M-T)</li>
        <li>Cover chapters from <a href="intro-to-cpp/">Intro to C++</a> module
        not covered last year (Th-F)
        </li>
      </ul>
      <li>Drive code (F-St)</li>
    </ul>
    <h4 id="Week_2">Week 2</h4>
    <ul>
      <li>Rookie training</li>
      <ul>
        <li>As much C++ as we can finish (M-T)</li>
        <li>State machines (simple and event-driven, Th-St)</li>
      </ul>
      <li>Veteran training</li>
      <ul>
        <li>Selected topics in C++</li>
        <ul>
          <li>Real-time software design (M)</li>
          <li>Threading, sockets (M-T)</li>
        </ul>
      </ul>
      <li>Develop subsystem abstractions (Depends: mechanical subsystem
      designs, Th-St)</li>
    </ul>
    <h4 id="Week_3">Week 3</h4>
    <ul>
      <li>Rookie training</li>
      <ul>
        <li>WPILib, <a href="robot-software/#Design_patterns">robot design
        patterns</a> (M-T)
        </li>
      </ul>
      <li>Veteran training</li>
      <ul>
        <li>Feedback control abstractions (M-T)</li>
        <li>Feedforward and models?</li>
      </ul>
      <li>Decide what should use feedback control (M-St)</li>
    </ul>
    <h4 id="Week_4">Week 4</h4>
    <ul>
      <li>Start autonomous (M-St)</li>
      <li>Refine subsystems (M-St)</li>
    </ul>
    <h4 id="Week_5">Week 5</h4>
    <ul>
      <li>Testing and feedback control tuning (M-St)</li>
    </ul>
    <h4 id="Week_6">Week 6</h4>
    <ul>
      <li>Testing and feedback control tuning (M-St)</li>
    </ul>
    <h2 id="Instruction_notes">Instruction notes</h2>
    <p>The C++ teaching material has weekly assignments the students are
    expected to work on outside of build sessions and submit via Git. Mentors
    review their submissions and provide feedback during code review. The
    student is only done when review is complete and all issues are addressed.
    While exercises are nominally weekly, they often stretch into three weeks
    because students don't do them.</p>
    <p>The most common issue during review is formatting mistakes. Students can
    use wpiformat to fix almost all complaints in this area.</p>
    <h2 id="Submission">Submission</h2>
    <p>Assignment submissions will be made via Git. To start, make an account
    on <a href="https://github.com/">GitHub</a> if you don't already have one.
    See <a href="intro-to-git/#10_most_commonly_used_Git_commands">this cheat
    sheet</a> for an overview of the most commonly used Git commands. Make
    commits to your repository as often as you feel is necessary.</p>
    <p>The following is an example of the desired Git repository structure and
    naming scheme for the Intro to C++ module. Your source files may have
    different names from those shown or not exist. This may look confusing so
    feel free to ask for help!</p>
    <ul>
      <li>frc3512-assignments (Git repository root)</li>
      <li style="list-style: none; display: inline">
        <ul>
          <li>chapter01 (workspace)</li>
          <li style="list-style: none; display: inline">
            <ul>
              <li>drill02 (project)</li>
              <li style="list-style: none; display: inline">
                <ul>
                  <li>src</li>
                  <li style="list-style: none; display: inline">
                    <ul>
                      <li>ExampleClass.cpp</li>
                      <li>ExampleClass.hpp</li>
                      <li>Main.cpp</li>
                    </ul>
                  </li>
                  <li>Makefile</li>
                </ul>
              </li>
              <li>exercise13 (project)</li>
              <li style="list-style: none; display: inline">
                <ul>
                  <li>src</li>
                  <li style="list-style: none; display: inline">
                    <ul>
                      <li>Main.cpp</li>
                    </ul>
                  </li>
                  <li>README.txt</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>chapter11 (workspace)</li>
          <li style="list-style: none; display: inline">
            <ul>
              <li>drill14 (project)</li>
              <li style="list-style: none; display: inline">
                <ul>
                  <li>src</li>
                  <li style="list-style: none; display: inline">
                    <ul>
                      <li>Main.cpp</li>
                    </ul>
                  </li>
                  <li>license.txt</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>cool-lab (workspace)</li>
          <li style="list-style: none; display: inline">
            <ul>
              <li>first-section-name (project)</li>
              <li style="list-style: none; display: inline">
                <ul>
                  <li>src</li>
                  <li style="list-style: none; display: inline">
                    <ul>
                      <li>Main.cpp</li>
                      <li>SupportFile.cpp</li>
                      <li>SupportFile.hpp</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <ol>
      <li>Folders use lowercase only and files use camel case (first letter of
      each word capitalized and the rest lowercase)</li>
      <li>Source code goes in the <code>src</code> directory while other files
      like licenses, makefiles, READMEs and data go outside of it</li>
      <li>For labs, submit all files used according to this format unless
      otherwise stated in the lab.</li>
    </ol>
    <p>It's convention to define <code>main()</code> in a file called
    <code>Main.cpp</code>, but it isn't required and may not make sense for
    projects with only one file.</p>
    <p>Submissions will have our formatter run on them. After setting it up
    according to <a href="../bootstrap/#Formatter">these instructions</a>,
    place <a href="robot-software/generic/.clang-format">.clang-format</a>,
    <a href="robot-software/generic/.styleguide">.styleguide</a>, and <a href=
    "robot-software/generic/.styleguide-license">.styleguide-license</a> in the
    root directory of your repository. You may modify
    <code>.styleguide-license</code> to use your name.</p>
    <h3 id="Option_1.3A_VS_Code_Workspace">Option 1: VS Code Workspace</h3>
    <ol>
      <li>Create a folder/directory that will be the root directory of your
      project</li>
      <li>Open that folder in VS Code with <code>File &gt; Open Folder</code>
      in the menu bar</li>
      <li>Install the CMake Tools extension</li>
      <li>Press Ctrl+Shift+P to open the command pallete or use <code>View &gt;
      Command Pallete</code> in the menu bar</li>
      <li>Type in <code>CMake: Quick Start</code>, choose a name for the
      project, and select an executable</li>
    </ol>
    <p>To run your code, type <code>CMake: Build</code> in the command pallete.
    You may need to modify the executable and include path.</p>
    <p>Include the following in the .gitignore in the root directory of your
    Git repository:</p>
    <pre>build/</pre>
    <h3 id="Option_2.3A_Alternate_editor">Option 2: Alternate editor</h3>
    <p>If you want to use a different IDE such as Vim, provide a Makefile in
    each problem folder to compile the executable. "workspaces" and "projects"
    aren't relevant here, but follow the directory layout. Here's an <a href=
    "Makefile">example Makefile</a> which recursively finds all the source
    files in the <code>src</code> directory and compiles Debug and Release
    versions of them. The <code>NAME</code> field should be edited before use.
    The following entries should be included in the repository's .gitignore
    file:</p>
    <pre>*.d
*.o
Debug/
Release/</pre>
  </div>
</body>
</html>
