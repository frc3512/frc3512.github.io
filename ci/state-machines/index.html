<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="description" content="State machines">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>State machines - FRC Team 3512</title>
  <link rel="stylesheet" type="text/css" href="../../main.css">
  <link rel="shortcut icon" type="image/ico" href="../../favicon.ico">
</head>
<body>
  <input type="checkbox" id="ham-menu">
  <label for="ham-menu">
    <div class="hide-des">
      <span class="menu-line"></span>
      <span class="menu-line"></span>
      <span class="menu-line"></span>
      <span class="menu-line"></span>
      <span class="menu-line"></span>
      <span class="menu-line"></span>
    </div>

  </label>
  <div class="full-page-blue"></div>
  <div class="ham-menu">
    <ul class="centre-text bold-text">
      <li>
        <a href="../../">Home</a>
      </li>
      <li>
        <a href="../../admin/">Admin</a>
      </li>
      <li>
        <a href="../../bootstrap/">Developer Bootstraps</a>
      </li>
      <li>
        <a href="../../vpn/">VPN Setup</a>
      </li>
      <li>
        <a href="../ci/">Curriculum</a>
      </li>
      <li>
        <a href="../../fll/">FLL</a>
      </li>
      <li>
        <a href="../../archives/">Archives</a>
      </li>
    </ul>
  </div>
  <div class="body">
    <h1>State machines</h1><strong>Prerequisites:</strong> <a href=
    "../intro-to-cpp/">Intro to C++</a>
    <h2 id="Labs">Labs</h2>
    <ul>
      <li>
        <a href="state-machine/">State machine lab</a>
      </li>
      <li>
        <a href="event-framework/">Event framework lab</a>
      </li>
    </ul>
    <h2 id="State_machines">State machines</h2>
    <p>A state machine is an abstract machine which represents a certain number
    of states and can only be in one at a time. The state at any given time is
    called the <i>current state</i>. It can change from one state to another
    when initiated by a triggering event or condition; this is called a
    <i>transition</i>. We use <i>finite state machines</i> on our robots, which
    contain a finite set of states. Typically, code is executed when first
    transitioning to a state. While in that state, some code is executed to
    effect the system towards the next state. Also, a condition is checked for
    state transition. If a transition occurs, code may be executed when leaving
    a state. See the state machine labs for more. Our 2015 robot code had a
    <a href=
    "https://github.com/frc3512/Robot-2015/blob/main/src/main/include/StateMachine.hpp">
    state machine</a> class to manage state machines and a <a href=
    "https://github.com/frc3512/Robot-2015/blob/main/src/main/include/State.hpp">
    state</a> class to contain lambdas of code to perform the aforementioned
    actions.</p>
    <p>State machines can be used to automate a sequence of actions. We use
    these predominantly for the autonomous period of our robot code, but this
    functionality can prove useful for performing user actions as well. For
    example, we used a state machine in our 2015 robot code to control the
    auto-stacking process. As goals where reached by the elevator system, the
    software would advance through the various states defined in the state
    machine until the idle state was reached. The elevator subsystem used a PID
    controller to travel to the various goals required for state transitions
    (see <a href="state-machine/">the state machine lab</a>).</p>
    <p>As a side note, WPILib's Command-Based programming paradigm, which
    involves creating and scheduling commands and command groups, is
    essentially a verbose way of allowing teams to make and use state machines.
    This verbosity is why our 2015 robot used custom state machine management
    classes; we only had to assign a few lambdas instead of writing boilerplate
    classes, like <a href=
    "https://github.com/frc3512/Robot-2015/blob/main/src/main/cpp/autonomous/AutoOneCanLeft.cpp">
    this</a>.</p>
  </div>
</body>
</html>
